package com.problem;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class leetcode_30 {
	/*
	 * 难度困难318给定一个字符串 s 和一些长度相同的单词 words。
	 * 找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
	注意子串要与 words 中的单词完全匹配，中间不能有其他字符，
	但不需要考虑 words 中单词串联的顺序。
	示例 1：
	输入：
	  s = "barfoothefoobarman",
	  words = ["foo","bar"]
	输出：[0,9]
	解释：
	从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
	输出的顺序不重要, [9,0] 也是有效答案。

*/

	public static void main(String[] args) {
		String s = "barfoothefoobarman";
		String[] words = {"foo","bar"};
		List list = findSubstring(s,words);
		System.out.println(list);
	}
    public static List<Integer> findSubstring(String s, String[] words) {
    	List<Integer> res = new ArrayList<>();
    	if(s==null||s.length()==0||words==null||words.length==0)
    		return res;
    	int one_word = words[0].length();
    	int words_num = words.length;
    	int all_len = one_word * words_num;
    	HashMap<String,Integer> hm = new HashMap<String,Integer>();
    	for(String word:words) {
    		hm.put(word, hm.getOrDefault(word,0)+1);
    	}
    	for(int i=0;i<s.length()-all_len+1;i++) {
    		String tmp = s.substring(i,i+all_len);
    		HashMap<String,Integer> tmp_map = new HashMap<>();
    		for(int j=0;j<all_len;j+=one_word) {
    			String w = tmp.substring(j,j+one_word);
    			tmp_map.put(w,tmp_map.getOrDefault(w, 0)+1);
    		}
    		if(tmp_map.equals(hm))
    			res.add(i);
    	}
    	return res;
    }

}
