package com.problem;

public class leetcode_443 {
	/*
	 * 443. 压缩字符串
	给定一组字符，使用原地算法将其压缩。
	压缩后的长度必须始终小于或等于原数组长度。
	数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。
	在完成原地修改输入数组后，返回数组的新长度。
 	进阶：
	你能否仅使用O(1) 空间解决问题？
 
	示例 1：
	输入：
	["a","a","b","b","c","c","c"]
	输出：
	返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
	说明：
	"aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。
	
	示例 2：
	输入：
	["a"]
	输出：
	返回 1 ，输入数组的前 1 个字符应该是：["a"]
	解释：
	没有任何字符串被替代。
	
	示例 3：
	输入：
	["a","b","b","b","b","b","b","b","b","b","b","b","b"]
	输出：
	返回 4 ，输入数组的前4个字符应该是：["a","b","1","2"]。
	解释：
	由于字符 "a" 不重复，所以不会被压缩。"bbbbbbbbbbbb" 被 “b12” 替代。
	注意每个数字在数组中都有它自己的位置。*/

	public static void main(String[] args) {
		char[] chars ={'a','b'};
		int n = compress(chars);
		System.out.println(n);
	}
    public static int compress(char[] chars) {
    	int i=0,t=0;
    	StringBuilder sb = new StringBuilder();
    	while(i<chars.length) {
    		t=i+1;
    		while(t<chars.length){
                if(chars[i]==chars[t])
                    t++;
            }
    		int len = t-i;
    		sb.append(chars[i]);
    		sb.append(len);
            i=t;
    	}
    	return sb.length();
    }
//保留指针 anchor，是当前读到连续字符串的起始位置。从左到右读取。
//当到最后一个字符，或下一个字符与当前不同时，则到达连续区块的结尾。就从 write 
//写入压缩的结果。chars[anchor] 为字符，read - anchor + 1 （若大于 1）为长度。
  

}
